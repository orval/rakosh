const { unified } = require('fix-esm').require('unified')
const remarkParse = require('fix-esm').require('remark-parse').default
const remarkDirective = require('fix-esm').require('remark-directive').default
const remarkStringify = require('fix-esm').require('remark-stringify').default
const { visit } = require('unist-util-visit')

// markdown is parsed into an AST so that markdown directives can be replaced
// with JSX for react-admonitions, then compiled back into markdown
function processMarkdown (markdown) {
  const processor = unified()
    .use(remarkParse)
    .use(remarkDirective)
    .use(directiveToReactAdmon)
    .use(remarkStringify)

  return processor.processSync(markdown).toString()

  function directiveToReactAdmon () {
    return (tree) => {
      visit(tree, (node) => {
        if (node.type === 'containerDirective') {
          // containerDirective is switched to a paragraph
          node.type = 'paragraph'

          let title = ''

          // pull the title from AST generated by :::note[title]
          const children = node.children || (node.children = [])
          if (children.length > 0 &&
            children[0].type === 'paragraph' &&
            children[0].data &&
            children[0].data.directiveLabel &&
            children[0].data.directiveLabel === true &&
            children[0].children &&
            children[0].children.length > 0 &&
            children[0].children[0].type === 'text'
          ) {
            title = ` title="${children[0].children[0].value}"`
            children[0].children.shift()
          }

          // wrap the children in an Admonition element
          children.unshift({
            type: 'html',
            value: `<Admonition type="${node.name}"${title}>\n`
          })

          children.push({ type: 'html', value: '\n</Admonition>' })
        }
      })
    }
  }
}

module.exports = processMarkdown
